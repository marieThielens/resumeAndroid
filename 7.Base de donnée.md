# SQLite

-Le contexte : l'état actuel de l'application / de l'objet. Il permet aux objets nouvellement crées de comprendre ce qu'il s'est passé.
`getApplicationContext()`
`getContext()`
`getBaseContext()`
``

## Les différents éléments

1. Un fichier avec les données que je vais stoquer (nom, prenom..). Les différentes colonnes de ma base ( models / product.java) `Anniversaire` ou `Product`
2. Un fichier `Anniversairecrud` ou `ProductDAO`  qui va permettre de manipuler en lecture et ecriture la base de donnée
3. Un fichier `AnnfiStructureDB` ou `DbHelper` c'est la structure pour accéder à ma base de donnée.

[Structure de dossier](./img/StructureDossier.PNG)

## 1. Models > Product.java

- Un fichier avec les données que je vais stoquer (nom, prenom..). Les différentes colonnes de ma base
- La méthode `toString()` pour la mise en forme du texte 

```java
package com.example.courses.models;

import androidx.annotation.NonNull;

// Modele Pojo : plain old java object
// un objet avec des champs, constructeur
public class Product {

    private int id; // id va etre généré par la base de donnée. Donc il faut 2 constructeur
    private @NonNull String name; // specifier que ce n'est pas null
    private int quantity;
    private double price;
    private String category;

    // Premier constructeur sans l'id
    public Product(@NonNull String name, int quantity, String category, double price ) {
        this.name = name;
        this.quantity = quantity;
        this.price = price;
        this.category = category;
    }
    // Avec l'id
    public Product(int id, @NonNull String name, int quantity,String category, double price) {
        this(name, quantity, category, price);
        this.id = id;
    }

    // Getters and setters
    public int getId() { return id; }
    public void setId(int id) { this.id = id; }
    @NonNull public String getName() { return name; }
    public void setName(@NonNull String name) { this.name = name; }
    public int getQuantity() { return quantity; } 
    public void setQuantity(int quantity) { this.quantity = quantity; }
    public double getPrice() { return price; }
    public void setPrice(double price) { this.price = price; }
    public String getCategory() { return category; }
    public void setCategory(String category) { this.category = category; }

    // La mise en forme de mon texte
    @Override 
    public String toString() {
        return "Product{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", quantity=" + quantity +
                ", price=" + price +
                ", category='" + category + '\'' +
                '}';
    }
}
```

## Un fichier qui contient toutes les commandes sql

```java
public class DbInfo {
    // Les infos nécéssaire pour bien créer ma base de donnée
    public static final String DB_NAME = "my_db"; // Le nom de la db
    public static final int DB_VERSION = 1; // la version de la db

    public static class Product { // A chaque fois que je vais sauvegarder je crée une classe static pour chaque element
        // La classe static qui contient les infos de la table (le nom des colonnes .. )

        public static final String TABLE_NAME = "product"; // le nom du tableau
        public static final String COLUMN_ID = "_id";// Nom des colonnes
        public static final String COLUMN_NAME = "name" ;
        public static final String COLUMN_CATEGORY =  "catdegory";
        public static final String COLUMN_QUANTITY = "quantity";
        public static final String COLUMN_PRICE = "price";

        // requetes (DDL )  Pour créer le tabeau et ses colonnes
        public static final String REQUEST_CREATE =
                "CREATE TABLE " + Product.TABLE_NAME + " ( "
                    + Product.COLUMN_ID + " INTEGER PRIMARY KEY AUTOINCREMENT, "
                    + Product.COLUMN_NAME + " TEXT NOT NULL, "
                    + Product.COLUMN_CATEGORY + "TEXT, "
                    + Product.COLUMN_QUANTITY + " INT NOT NUL, "
                    + Product.COLUMN_PRICE + " NUMERIQUE NOT NUL "
                    + ");";

        public static final String REQUEST_DELETE = "DROP TABLE )" + Product.TABLE_NAME + ";";

    }
}

```

## Le fichier Crud - Manipuler la base de donnéee en lecture et écriture

- Créer un dossier db
- créer un fichier ProductDAO ou AnniversaireCrud

```java
// Interagir avec notre models. Symbolise les actions possible à faire
// Va ontenir des méthodes d'interaction pour accéder en écriture, lecture. Se connecter à la db,
// supprimer la db
public class ProductDAO {

    // Va avoir besoin de plusierus champs. Du contexte
    private Context context; // besoin de savoir le context
    private DbHelper dbHelper;
    private SQLiteDatabase db;

    // constructeur

// Lui donner le contexte pour qu'il puisse faire des choses avec
    public ProductDAO(Context context) { this.context = context; }

    // Méthode . De connection et de déconnection. Accéder aux information en lecture et écriture
    public ProductDAO openWritable() {
        dbHelper = new DbHelper(context);
        // générer mon accès vers ma base de donné
        db = dbHelper.getWritableDatabase(); // avoir accès en écriture
        return this;
    }
    public ProductDAO openReadable() {
        dbHelper = new DbHelper(context);
        // générer mon accès vers ma base de donné
        db = dbHelper.getReadableDatabase(); // acces en lecture
        return this;
    }
    // Méthode qui va simboliser la fermetucre en connection
    public void close() {
        db.close();
        dbHelper.close();
    }
    // CRUD ( create, read, update, delete ). C'est ici qu'on centralise nos interaction
    private Product cursorToProduct(Cursor c) {
        int id = c.getInt(c.getColumnIndex(DbInfo.Product.COLUMN_ID));
        String name = c.getString(c.getColumnIndex(DbInfo.Product.COLUMN_NAME));
        int quantity = c.getInt(c.getColumnIndex(DbInfo.Product.COLUMN_QUANTITY));
        String category = c.getString(c.getColumnIndex(DbInfo.Product.COLUMN_CATEGORY));
        double price = c.getDouble(c.getColumnIndex(DbInfo.Product.COLUMN_PRICE));

        return new Product(id, name, quantity, category, price);
    }
    // Create ... A remettre . On rajoute 1 produit
    private ContentValues createCV(Product product) {
        // Permet de convertir un "Product" en "ContentValues" pour utiliser les données lors d'un insert ou update
        ContentValues cv = new ContentValues();
        cv.put(DbInfo.Product.COLUMN_NAME, product.getName());
        cv.put(DbInfo.Product.COLUMN_CATEGORY, product.getCategory());
        cv.put(DbInfo.Product.COLUMN_QUANTITY, product.getQuantity());
        cv.put(DbInfo.Product.COLUMN_PRICE, product.getPrice());

        return cv;
    }
    // Create
    public long insert(Product product) {
        ContentValues cv = createCV(product);
        return db.insert(DbInfo.Product.TABLE_NAME, null, cv);
    }
    // read
    public Product getById(int id) {
        Cursor cursor = db.query(
                DbInfo.Product.TABLE_NAME,
                null,// Null ici symbolise qu'on prend tout
                DbInfo.Product.COLUMN_ID + " = ? ", // Where
                new String[] { String.valueOf(id)},
                null,
                null,
                null );
        // il a recu un cursor. Si il n'y a pas de résultat
        if(cursor.getCount() ==0) {
            return null;
        }
        cursor.moveToFirst(); // Place le curseur sur l'élément trouv"

        return cursorToProduct(cursor); // renvoi le produit etrait du curseur
    }
    public List<Product> getAll() {
        Cursor cursor = db.query(DbInfo.Product.TABLE_NAME, null, null, null, null, null, null);
        List<Product> products = new ArrayList<>();
        if(cursor.getCount() == 0) {
            return products;
        }
        cursor.moveToFirst();
        while(! cursor.isAfterLast()) {
            Product p = cursorToProduct(cursor);
            products.add(p);

            cursor.moveToNext();
        }
        return products;
    }
    // Update
    public boolean update(long id, Product product) {
        ContentValues cv = createCV(product);

        int nbRow = db.update(DbInfo.Product.TABLE_NAME, cv,
                DbInfo.Product.COLUMN_ID + " = ?",
                new String[]{ String.valueOf(id) });

        return nbRow == 1;
    }

    // delete
    public boolean delete(int id) { // on delete sur base de l'id
       int nbRow = db.delete(DbInfo.Product.TABLE_NAME,
               DbInfo.Product.COLUMN_ID + " = ?",  // ? remplace id
               new String[]{String.valueOf(id) } ); // Le nom de la table , la clause where
       return nbRow == 1;
    }
}
```

## Le fichier AnnifStructureDB ou DBHelper pour mettre à jour la db

`SQLiteOpenHelper(context, name, factory, version)` : composant qui code déjà pas mal d'accès à la base de donnée. 
`onCreate()` : on explique ce qu'il se passe lorsque je je crée une base de donnée
`onUpgrade()` : lorsque je met à jour ma base de donnée
- 

```java
// helper qui m'aide à mettre à jour ma base de donnée
public class DbHelper extends SQLiteOpenHelper {  // SQLiteOpenHelper classe qui prend en charge l'interaction avec le db

    // Appelle le constructeur parent en lui donnant les info nécessaire
    public DbHelper(Context context) { // Context : comme l'identité runtime de mon application. Savoir qui l'a appelé
        //
        super(context, DbInfo.DB_NAME, null, DbInfo.DB_VERSION ); // Quel est le nom ? quel est la version
    }
    // Sera appellée si l'app ne contient pas la base de donnée
    @Override
    public void onCreate(SQLiteDatabase db) { // Creation de la db. fichier dbIndo ligne 19
        db.execSQL(DbInfo.Product.REQUEST_CREATE); // manipulation du sql
    }
    // Si l'appli contient la bd mais avec une version précédente
    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        // Pour la mise a jour on détruit et on recrée
        db.execSQL(DbInfo.Product.REQUEST_DELETE);
        onCreate(db); // On recrée
    }
}
```
